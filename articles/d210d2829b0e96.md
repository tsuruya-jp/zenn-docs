---
title: "Rustã§Lambdaã‚’æ›¸ã„ã¦sam local start-apiã§LocalStackã®DynamoDBã‚’ä½¿ã†"
emoji: "ğŸ¥"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Rust", "LocalStack", "sam", "Lambda", "DynamoDB"]
published: true
published_at: 2025-10-02 19:00
---

## ã¯ã˜ã‚ã«

Rustã®é–€ã‚’å©ã„ã¦ã‹ã‚‰ã‚¤ãƒ³ãƒ—ãƒƒãƒˆã—ã¦ã„ã‚‹ã ã‘ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã£ã¦ãªã‹ã£ãŸã®ã§ã€ã¨ã‚Šã‚ãˆãšãªã‚“ã‹ã‚„ã£ã¦ã¿ã‚ˆã†ã¨ã„ã†ã“ã¨ã§API Gateway + Lambdaã®æ§‹æˆã§APIã‚’ä½œã‚‹ã“ã¨ã«ã€‚
ã‚µãƒ¼ãƒãƒ¬ã‚¹ã¯é‹ç”¨ã‚³ã‚¹ãƒˆãŒä½ã‹ã£ãŸã‚Šã¨çµæ§‹å¥½ããªã‚“ã§ã™ãŒã€å‹•ä½œç¢ºèªãŒãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã‹ã‚‰ã˜ã‚ƒãªã„ã¨ã§ããªã„ã—é¢å€’ã ãªãƒ¼ãªã‚“ã¦æ€ã£ã¦ã„ã¾ã—ãŸã€‚
ãã‚“ãªã¨ãã«`sam local start-api`ã§ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§API Gateway + Lambdaã‚’å®Ÿè¡Œã§ãã‚‹ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã‚Šã•ã£ããã‚„ã£ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- Rust
- Amazon API Gateway
- Amazon DynamoDB
- AWS Lambda
- LocalStack

## æ§‹æˆå›³
ã‹ãªã‚Šã‚¢ãƒã‚¦ãƒˆãªå›³ã§ã™ãŒã€ã‚¤ãƒ¡ãƒ¼ã‚¸ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã™ã€‚
![](https://storage.googleapis.com/zenn-user-upload/f49240264341-20251001.png)

## ã‚µãƒ³ãƒ—ãƒ«
1ã‹ã‚‰æ‰‹é †ã‚’ç´¹ä»‹ã—ã¾ã™ãŒã€æ€¥ã„ã§ã„ã‚‹æ–¹ã®ãŸã‚ã«å®Œæˆã—ãŸã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¬é–‹ã—ã¾ã™ã€‚
å¿…è¦ã«å¿œã˜ã¦ã“ã¡ã‚‰ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚

https://github.com/tsuruya-jp/rust-samlocalapi-localstack

## Rustã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹
ã¾ãšã¯samã§ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã‚’å‹•ã‹ã›ã‚‹ã‚ˆã†ã«Rustã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚

1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
    ```bash
    cargo new project
    # or
    cargo init .
    ```
2. template.ymlã‚’ä½œæˆ

    ã‚µãƒ³ãƒ—ãƒ«ã¯`/`ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§GETã¨POSTã®APIã‚’ä½œæˆã—ã¾ã™ã€‚

    ```yml:template.yml
    AWSTemplateFormatVersion: '2010-09-09'
    Transform: AWS::Serverless-2016-10-31
    Description: Rust Lambda Function with LocalStack

    Globals:
    Function:
        Runtime: provided.al2023
        Architectures:
        - x86_64
        Tracing: Active
        CodeUri: ./
        Handler: bootstrap
        Timeout: 30
        MemorySize: 128
        Environment:
        Variables:
            RUST_BACKTRACE: 1
    Api:
        OpenApiVersion: 3.0.0

    Resources:
    GetFunction:
        Type: AWS::Serverless::Function
        Metadata:
        BuildMethod: rust-cargolambda
        BuildProperties:
            Binary: get_function
        Properties:
        Events:
            GetRoot:
            Type: Api
            Properties:
                Path: /
                Method: GET

    PostFunction:
        Type: AWS::Serverless::Function
        Metadata:
        BuildMethod: rust-cargolambda
        BuildProperties:
            Binary: post_function
        Properties:
        Events:
            PostRoot:
            Type: Api
            Properties:
                Path: /
                Method: POST
    ```
3. cargo.tomlä¿®æ­£

    æœ€ä¸‹éƒ¨ã«è¿½åŠ ã™ã‚‹

    ```toml:cargo.toml
    [[bin]]
    name = "get_function"
    path = "src/get_function.rs"

    [[bin]]
    name = "post_function"
    path = "src/post_function.rs"
    ```

4. å¿…è¦ãªã‚¯ãƒ¬ãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹

    ```bash
    cargo add aws_config
    cargo add serde
    cargo add tokio --features macros
    cargo add tracing --features log
    cargo add tracing-subscriber --no-default-features --features fmt
    cargo add aws_lambda_events
    cargo add lambda_runtime
    ```
5. Lambdaãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ä½œæˆã™ã‚‹

    `src/`é…ä¸‹ã«`cargo.toml`ã«è¨˜è¼‰ã—ãŸãƒ‘ã‚¹é€šã‚Šã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚‹

    ```
    ./
    â”œâ”€â”€ Cargo.lock
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ src
    â”‚Â Â  â”œâ”€â”€ get_function.rs
    â”‚Â Â  â””â”€â”€ post_function.rs
    â””â”€â”€ template.yml
    ```
6. å®Ÿè£…ã™ã‚‹

    ã¨ã‚Šã‚ãˆãšãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ã ã‘ã®å‡¦ç†ã‚’æ›¸ãã€‚`post_function.rs`ã‚‚åŒã˜å®Ÿè£…ã§è‰¯ã„ã€‚

    ```rs:get_function.rs
    use aws_lambda_events::{apigw::{ApiGatewayProxyRequest, ApiGatewayProxyResponse}, http::HeaderMap};
    use lambda_runtime::{Error, LambdaEvent, run, service_fn};

    pub async fn handler(
        _event: LambdaEvent<ApiGatewayProxyRequest>,
    ) -> Result<ApiGatewayProxyResponse, Error> {

        let mut headers = HeaderMap::new();
        headers.insert("content-type", "text/html".parse().unwrap());

        let resp = ApiGatewayProxyResponse {
            status_code: 200,
            multi_value_headers: headers.clone(),
            is_base64_encoded: false,
            body: Some("Hello AWS Lambda HTTP request".into()),
            headers,
        };
        Ok(resp)
    }

    #[tokio::main]
    async fn main() -> Result<(), Error> {
        run(service_fn(handler)).await
    }
    ```
7. ãƒ­ãƒ¼ã‚«ãƒ«ã§APIã‚’å‹•ã‹ã™

    1. ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦APIã‚µãƒ¼ãƒã‚’èµ·å‹•ã™ã‚‹
        ```bash
        sam build
        sam local start-api
        ```

    2. ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹
        ```bash
        curl --location 'http://127.0.0.1:3000/'
        ```

    3. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒè¿”ã•ã‚Œã‚‹
        ```txt
        Hello AWS Lambda HTTP request
        ```

ã¾ãšã¯ã“ã‚Œã§ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§API Gateway + Lambdaã®APIã‚µãƒ¼ãƒã‚’å‹•ã‹ã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## LocalStackã®ç’°å¢ƒã‚’ä½œã‚‹
æ¬¡ã¯Dockerã§`LocalStack`ã®`DynamoDB`ã‚’ç«‹ã¡ä¸Šã’ã¾ã™ã€‚

1. `docker-compose.yml`ã‚’ä½œæˆã™ã‚‹

    LocalStackã¯ã„ã‚ã‚“ãªAWSã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§èµ·å‹•ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ä»Šå›ã¯`DynamoDB`ã®ã¿ã§è‰¯ã„ã®ã§`SERVICES=dynamodb`ã¨ã—ã¦ãŠãã¾ã™ã€‚

    ```yml:docker-compose.yml
    services:
    localstack:
        image: localstack/localstack:latest
        ports:
        - "4566:4566"
        environment:
        - SERVICES=dynamodb
        - AWS_ACCESS_KEY_ID=dummy
        - AWS_SECRET_ACCESS_KEY=dummy
        - AWS_DEFAULT_REGION=ap-northeast-1
    ```
2. `LocalStack`ã‚’èµ·å‹•ã™ã‚‹

    1. ã‚³ãƒ³ãƒ†ãƒŠã‚’èµ·å‹•ã™ã‚‹
        ```bash
        docker compose up -d
        ```
    2. LocalStackã®èµ·å‹•çŠ¶æ³ã‚’ç¢ºèªã™ã‚‹
        ```bash
        curl -s localhost:4566/_localstack/health | jq .
        ```
        è¿”å´å†…å®¹
        ```json
        {
        "services": {
            "acm": "disabled",
            "apigateway": "disabled",
            "cloudformation": "disabled",
            "cloudwatch": "disabled",
            "config": "disabled",
            "dynamodb": "available",
            "dynamodbstreams": "available",
            "ec2": "disabled",
            "es": "disabled",
            "events": "disabled",
            "firehose": "disabled",
            "iam": "disabled",
            "kinesis": "available",
            "kms": "disabled",
            "lambda": "disabled",
            "logs": "disabled",
            "opensearch": "disabled",
            "redshift": "disabled",
            "resource-groups": "disabled",
            "resourcegroupstaggingapi": "disabled",
            "route53": "disabled",
            "route53resolver": "disabled",
            "s3": "disabled",
            "s3control": "disabled",
            "scheduler": "disabled",
            "secretsmanager": "disabled",
            "ses": "disabled",
            "sns": "disabled",
            "sqs": "disabled",
            "ssm": "disabled",
            "stepfunctions": "disabled",
            "sts": "disabled",
            "support": "disabled",
            "swf": "disabled",
            "transcribe": "disabled"
        },
        "edition": "community",
        "version": "4.8.2.dev13"
        }
        ```

    3. aws cliã‚’å®Ÿè¡Œã—ã¦ã¿ã‚‹

        ```bash
        aws dynamodb list-tables
        ```

    4. å®Ÿè¡Œçµæœã‚’ç¢ºèªã™ã‚‹

        ```json
        {
            "TableNames": []
        }
        ```

        ã“ã®ã¨ã
        ```
        You must specify a region. You can also configure your region by running "aws configure".
        ```
        ã¨æ€’ã‚‰ã‚ŒãŸå ´åˆã€aws cliã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¦ã„ãªã„ã®ã§ã€`~/.aws/config`ã¨`~/.aws/credentials`ã‚’ä½œæˆã™ã‚‹ã€‚

        ã‚‚ã—ãã¯ã€`aws configure`ã‚³ãƒãƒ³ãƒ‰ã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’è¡Œã†ã€‚

        ```cfg:~/.aws/config
        [default]
        region = ap-northeast-1
        output = json
        ```

        ```cfg:~/.aws/credentials
        [default]
        aws_access_key_id = dummy
        aws_secret_access_key = dummy
        ```

## DynamoDBã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œã‚‹
LocalStackã¯ç„¡æ–™ãƒ—ãƒ©ãƒ³ã§ã¯ãƒ‡ãƒ¼ã‚¿ãŒæ°¸ç¶šåŒ–ã•ã‚Œãªã„ãŸã‚ã€ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã¯ã‚³ãƒ³ãƒ†ãƒŠã‚’èµ·å‹•ã™ã‚‹ãŸã³ã«åˆæœŸåŒ–ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
æ¯å›æ‰‹å‹•ã§ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã™ã‚‹ã®ã¯æ‰‹é–“ãªã®ã§ã€åˆæœŸåŒ–ç”¨ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚

ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã‚³ãƒ³ãƒ†ãƒŠå´ã®`/etc/localstack/init/ready.d`ã«é…ç½®ã™ã‚‹ã“ã¨ã§ã€Dockerã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•æ™‚ã«è‡ªå‹•ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

https://docs.localstack.cloud/aws/capabilities/config/initialization-hooks/

1. ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½œã‚‹
    ```bash:scripts/init.sh
    #!/bin/bash

    key_name="user_id"
    table_name="users"

    aws --endpoint-url=http://localstack:4566 dynamodb create-table \
        --table-name=$table_name \
        --attribute-definitions AttributeName=$key_name,AttributeType=S \
        --key-schema AttributeName=$key_name,KeyType=HASH \
        --billing-mode PAY_PER_REQUEST
    ```

2. `docker-compose.yml`ã‚’ä¿®æ­£ã™ã‚‹
    ```diff yml:docker-compose.yml
    services:
        localstack:
            image: localstack/localstack:latest
            ports:
            - "4566:4566"
            environment:
            - SERVICES=dynamodb
            - AWS_ACCESS_KEY_ID=dummy
            - AWS_SECRET_ACCESS_KEY=dummy
            - AWS_DEFAULT_REGION=ap-northeast-1
    +       volumes:
    +       - "./scripts:/etc/localstack/init/ready.d"
    ```

3. ã‚³ãƒ³ãƒ†ãƒŠã‚’å†èµ·å‹•ã™ã‚‹(ä½œã‚Šç›´ã™)

    ```
    docker compose up -d --force-recreate
    ```

    DynamoDBãŒä½œã‚‰ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹

    ```
    aws dynamodb list-tables
    ```

    ä½œã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹

    ```
    {
        "TableNames": [
            "users"
        ]
    }
    ```

## Lambdaã‚’æ”¹ä¿®ã™ã‚‹
å…ˆç¨‹ä½œæˆã—ãŸGETã®å®Ÿè£…ã«DynamoDBã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹å®Ÿè£…ã‚’ãŠã“ãªã„ã¾ã™ã€‚

ã¾ãšã€DynamoDB SDKã¨ JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºç”¨ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚

```bash
cargo add aws_sdk_dynamodb
cargo add serde_json
```
```rs:get_function.rs
use aws_config::BehaviorVersion;
use aws_lambda_events::{apigw::{ApiGatewayProxyRequest, ApiGatewayProxyResponse}, encodings::Body, http::HeaderMap};
use aws_sdk_dynamodb::Client;
use lambda_runtime::{Error, LambdaEvent, run, service_fn};
use serde_json::json;

pub async fn handler(
    _event: LambdaEvent<ApiGatewayProxyRequest>,
) -> Result<ApiGatewayProxyResponse, Error> {

    let config = aws_config::defaults(BehaviorVersion::latest())
        .endpoint_url("http://localstack:4566")
        .load()
        .await;

    let client = Client::new(&config);

    let list_resp = client.list_tables().send().await;

    let mut headers = HeaderMap::new();
    headers.insert("content-type", "application/json".parse().unwrap());

    let resp = match list_resp {
        Ok(resp) => {
            tracing::info!("Found {} tables", resp.table_names().len());
            let tables: Vec<String> = resp.table_names().iter().map(|s| s.to_string()).collect();

            let body = json!({
                "tables": tables
            }).to_string();

            ApiGatewayProxyResponse {
                status_code: 200,
                multi_value_headers: headers.clone(),
                is_base64_encoded: false,
                body: Some(Body::Text(body)),
                headers,
            }
        }
        Err(err) => {
            tracing::error!("Failed to list tables: {err:?}");

            let error_body = json!({
                "error": "Failed to list tables",
                "message": err.to_string()
            }).to_string();

            ApiGatewayProxyResponse {
                status_code: 500,
                multi_value_headers: headers.clone(),
                is_base64_encoded: false,
                body: Some(Body::Text(error_body)),
                headers,
            }
        }
    };

    Ok(resp)
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    tracing_subscriber::fmt().json()
        .with_max_level(tracing::Level::INFO)
        .with_current_span(false)
        .with_ansi(false)
        .without_time()
        .with_target(false)
        .init();

    run(service_fn(handler)).await
}
```

ãƒã‚¤ãƒ³ãƒˆã¯ã€DynamoDBã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’`http://localstack:4566`ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚
`http://127.0.0.1:4566`ã‚„`http://localhost:4566`ã®å ´åˆLocalStackã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚

ä¿®æ­£ãŒå®Œäº†ã—ãŸã‚‰å†åº¦`sam build`ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚

## ã‚³ãƒ³ãƒ†ãƒŠé–“ã®é€šä¿¡ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

å®Ÿè£…ãŒå®Œäº†ã—ã¾ã—ãŸãŒã€ã“ã®ã¾ã¾ã§ã¯Lambdaã®å‡¦ç†ãŒLocalStackã®ã‚³ãƒ³ãƒ†ãƒŠã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããšã‚¨ãƒ©ãƒ¼ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚

ç†ç”±ã¯ã€sam local ã§å®Ÿè¡Œã™ã‚‹Lambdaã¯dockerã‚³ãƒ³ãƒ†ãƒŠã§å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã§ã™ã€‚
ã‚³ãƒ³ãƒ†ãƒŠé–“ã®é€šä¿¡ãŒå¿…è¦ã«ãªã‚‹ãŸã‚localhostã§ã¯é€šä¿¡ãŒä¸å¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚

### å¯¾å¿œæ–¹æ³•

`sam local start-api`ã‚³ãƒãƒ³ãƒ‰ã«`--docker-network`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã¦å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã‚³ãƒ³ãƒ†ãƒŠé–“ã®é€šä¿¡ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚

1. LocalStackã‚³ãƒ³ãƒ†ãƒŠãŒèµ·å‹•ã—ã¦ã„ã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ç¢ºèªã™ã‚‹
    ```
    docker network ls
    ```

    ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå + _default`ã§å‘½åã•ã‚Œã¦ã„ã¾ã™ã€‚
    æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Œrust-samlocalapi-localstack_defaultã€ã¨ã„ã†åå‰ã§ä½œæˆã—ã¦ã„ã¾ã™ã€‚

    ```
    NETWORK ID     NAME                                              DRIVER    SCOPE
    b86fc161fc86   rust-samlocalapi-localstack_default               bridge    local
    ```

2. è¡¨ç¤ºã•ã‚ŒãŸ`NETWORK ID`ã‚’ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ä»˜ã‘ã‚‹
    ```
    sam local start-api --docker-network b86fc161fc86
    ```
3. APIã‚’å®Ÿè¡Œã™ã‚‹
    ```
    curl --location 'http://127.0.0.1:3000/'
    ```
    è¿”å´ã•ã‚Œã‚‹json
    ```
    {"tables":["users"]}
    ```

## æ¬¡å›
ã»ã¨ã‚“ã©å®Œæˆãªã‚“ã§ã™ãŒã€ä¸€æ—¦ã“ã“ã¾ã§ã«ã—ã¦ã€æ¬¡ã®è¨˜äº‹ã§DynamoDBã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼†ç™»éŒ²ã™ã‚‹å®Ÿè£…ã‚’æ›¸ã“ã†ã¨æ€ã„ã¾ã™ã€‚

GETã§ãƒ‡ãƒ¼ã‚¿å–å¾—ã€POSTã§ãƒ‡ãƒ¼ã‚¿ç™»éŒ²ã™ã‚‹ã‚ˆã†ãªAPIã‚’ä½œã‚‹ã®ã§ãŠæ™‚é–“ãŒã‚ã‚Œã°è¦‹ã¦ã¿ã¦ãã ã•ã„ã€‚
