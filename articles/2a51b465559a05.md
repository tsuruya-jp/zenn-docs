---
title: "ã€ç¶šãã€‘Rustã§Lambdaã‚’æ›¸ã„ã¦sam local start-apiã§LocalStackã®DynamoDBã‚’ä½¿ã†"
emoji: "ğŸ‘Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Rust", "LocalStack", "sam", "Lambda", "DynamoDB"]
published: true
---

## ã¯ã˜ã‚ã«

### å‰å›ã®ã‚ã‚‰ã™ã˜
sam local ã§API Gateway + Lambda ã®APIã‚µãƒ¼ãƒã‚’ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§èµ·å‹•ã—ã€dockerã§ç«‹ã¡ä¸Šã’ãŸLocalStackã®DynamoDBã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã„ã£ãŸå†…å®¹ã€‚
å‰å›ã®è¨˜äº‹ã§ã¯ã€DynamoDBç«‹ã¡ä¸Šã’æ™‚ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ã€APIã§ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ã¨ã“ã‚ã¾ã§ã‚’å®Ÿè·µã—ã¾ã—ãŸã€‚

https://zenn.dev/tsuruya/articles/d210d2829b0e96

### ä»Šå›ã‚„ã‚‹ã“ã¨
ä»Šå›ã¯ã€GETã§ãƒ‡ãƒ¼ã‚¿å–å¾—ã€POSTã§ãƒ‡ãƒ¼ã‚¿ç™»éŒ²ã™ã‚‹ã‚ˆã†ãªAPIã‚’å®Ÿè£…ã—ã€ã‚ˆã‚Šã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«è¿‘ã¥ã„ãŸå†…å®¹ã‚’å®Ÿè·µã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

ã“ã¡ã‚‰ã«ã‚µãƒ³ãƒ—ãƒ«ã‚’ç”¨æ„ã—ã¦ã„ã‚‹ã®ã§è‰¯ã‹ã£ãŸã‚‰è¦‹ã¦ãã ã•ã„ã€‚
https://github.com/tsuruya-jp/rust-samlocalapi-localstack

## `get_function.rs`ã®æ”¹ä¿®
DynamoDBã‹ã‚‰å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’jsonã«ã—ã¦è¿”ã—ãŸã‹ã£ãŸã®ã§Userã®æ§‹é€ ä½“ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚ã¾ãŸã€æ§‹é€ ä½“ã‚’jsonã«ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã®ã§serde_jsonã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãŠãã¾ã™ã€‚

ã‚ã¨ã¯å‰å›ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å–å¾—ã—ã¦ã„ãŸ`list_tables()`ã‹ã‚‰ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ã™ã‚‹`scan()`ãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›´ã—ã€å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’`Vec<User>`ã¸æ ¼ç´ã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒœãƒ‡ã‚£ã¸å«ã‚“ã§è¿”å´ã™ã‚‹ã ã‘ã«ãªã‚Šã¾ã™ã€‚
```rs:get_function.rs
use aws_config::BehaviorVersion;
use aws_lambda_events::{apigw::{ApiGatewayProxyRequest, ApiGatewayProxyResponse}, encodings::Body, http::HeaderMap};
use aws_sdk_dynamodb::Client;
use lambda_runtime::{Error, LambdaEvent, run, service_fn};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Deserialize, Serialize)]
struct User {
    user_id: String,
    name: String,
    email: String,
}

pub async fn handler(
    _event: LambdaEvent<ApiGatewayProxyRequest>,
) -> Result<ApiGatewayProxyResponse, Error> {

    let config = aws_config::defaults(BehaviorVersion::latest())
        .endpoint_url("http://localstack:4566")
        .load()
        .await;

    let client = Client::new(&config);

    let res = client
        .scan()
        .table_name("users")
        .send()
        .await;

    let mut headers = HeaderMap::new();
    headers.insert("content-type", "application/json".parse().unwrap());

    let resp = match res {
        Ok(resp) => {
            tracing::info!("Found {} items", resp.items().len());
            let mut users: Vec<User> = Vec::new();

            for item in resp.items() {
                if let (Some(user_id), Some(name), Some(email)) = (
                    item.get("user_id").and_then(|v| v.as_s().ok()),
                    item.get("name").and_then(|v| v.as_s().ok()),
                    item.get("email").and_then(|v| v.as_s().ok()),
                ) {
                    users.push(User {
                        user_id: user_id.clone(),
                        name: name.clone(),
                        email: email.clone(),
                    });
                }
            }

            let body = json!({
                "users": users,
                "count": users.len()
            }).to_string();

            ApiGatewayProxyResponse {
                status_code: 200,
                multi_value_headers: headers.clone(),
                is_base64_encoded: false,
                body: Some(Body::Text(body)),
                headers,
            }
        }
        Err(err) => {
            tracing::error!("Failed to scan users table: {err:?}");

            let error_body = json!({
                "error": "Failed to get users",
                "message": err.to_string()
            }).to_string();

            ApiGatewayProxyResponse {
                status_code: 500,
                multi_value_headers: headers.clone(),
                is_base64_encoded: false,
                body: Some(Body::Text(error_body)),
                headers,
            }
        }
    };

    Ok(resp)
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    tracing_subscriber::fmt().json()
        .with_max_level(tracing::Level::INFO)
        .with_current_span(false)
        .with_ansi(false)
        .without_time()
        .with_target(false)
        .init();

    run(service_fn(handler)).await
}
```

## `post_function.rs`ã®æ”¹ä¿®

get_function.rsåŒæ§˜ã«Useræ§‹é€ ä½“ã‚’å®šç¾©ã—jsonã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’DynamoDBã®`put_item()`ã§ç™»éŒ²ã™ã‚‹ã¨ã„ã†æµã‚Œã§ã™ã€‚è¿”å´ã™ã‚‹ãƒœãƒ‡ã‚£ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ç™»éŒ²ã—ãŸuserãã®ã¾ã¾ã‚’è¿”ã—ã¾ã™ã€‚

```rs:post_function.rs
use aws_config::BehaviorVersion;
use aws_lambda_events::{apigw::{ApiGatewayProxyRequest, ApiGatewayProxyResponse}, encodings::Body, http::HeaderMap};
use aws_sdk_dynamodb::Client;
use lambda_runtime::{Error, LambdaEvent, run, service_fn};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Deserialize, Serialize)]
struct User {
    user_id: String,
    name: String,
    email: String,
}

pub async fn handler(
    event: LambdaEvent<ApiGatewayProxyRequest>,
) -> Result<ApiGatewayProxyResponse, Error> {

    let config = aws_config::defaults(BehaviorVersion::latest())
        .endpoint_url("http://localstack:4566")
        .load()
        .await;

    let client = Client::new(&config);

    let mut headers = HeaderMap::new();
    headers.insert("content-type", "application/json".parse().unwrap());

    let body = event.payload.body.as_ref();

    let resp = match body {
        Some(body_str) => {
            match serde_json::from_str::<User>(body_str) {
                Ok(user) => {
                    let result = client
                        .put_item()
                        .table_name("users")
                        .item("user_id", aws_sdk_dynamodb::types::AttributeValue::S(user.user_id.clone()))
                        .item("name", aws_sdk_dynamodb::types::AttributeValue::S(user.name.clone()))
                        .item("email", aws_sdk_dynamodb::types::AttributeValue::S(user.email.clone()))
                        .send()
                        .await;

                    match result {
                        Ok(_) => {
                            let response_body = json!({
                                "message": "User created successfully",
                                "user": user
                            }).to_string();

                            ApiGatewayProxyResponse {
                                status_code: 201,
                                multi_value_headers: headers.clone(),
                                is_base64_encoded: false,
                                body: Some(Body::Text(response_body)),
                                headers,
                            }
                        }
                        Err(err) => {
                            eprintln!("Failed to put item: {err:?}");

                            let error_body = json!({
                                "error": "Failed to create user",
                                "message": err.to_string()
                            }).to_string();

                            ApiGatewayProxyResponse {
                                status_code: 500,
                                multi_value_headers: headers.clone(),
                                is_base64_encoded: false,
                                body: Some(Body::Text(error_body)),
                                headers,
                            }
                        }
                    }
                }
                Err(err) => {
                    eprintln!("Failed to parse JSON: {err:?}");

                    let error_body = json!({
                        "error": "Invalid request body",
                        "message": err.to_string()
                    }).to_string();

                    ApiGatewayProxyResponse {
                        status_code: 400,
                        multi_value_headers: headers.clone(),
                        is_base64_encoded: false,
                        body: Some(Body::Text(error_body)),
                        headers,
                    }
                }
            }
        }
        None => {
            let error_body = json!({
                "error": "Request body is required"
            }).to_string();

            ApiGatewayProxyResponse {
                status_code: 400,
                multi_value_headers: headers.clone(),
                is_base64_encoded: false,
                body: Some(Body::Text(error_body)),
                headers,
            }
        }
    };

    Ok(resp)
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    run(service_fn(handler)).await
}
```

## å®Ÿè¡Œã™ã‚‹

1. ãƒ“ãƒ«ãƒ‰ã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒã‚’èµ·å‹•ã™ã‚‹
    ```bash
    sam build
    sam local start-api --docker-network <DOCKER NETWORK ID>
    ```

2. POST

    ã¾ãšã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç™»éŒ²ã—ã¾ã™ã€‚

    - ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    ```bash
    curl --location 'http://127.0.0.1:3000/' \
    --header 'Content-Type: application/json' \
    --data-raw '{
    "user_id": "001",
    "name": "ç”°ä¸­å¤ªéƒ",
    "email": "tanaka@example.com"
    }'
    ```

    - ãƒ¬ã‚¹ãƒãƒ³ã‚¹
    ```json
    {
        "message": "User created successfully",
        "user": {
            "email": "tanaka@example.com",
            "name": "ç”°ä¸­å¤ªéƒ",
            "user_id": "001"
        }
    }
    ```

3. GET

    ä»Šç™»éŒ²ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ã—ã¾ã™ã€‚

    - ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    ```bash
    curl --location 'http://127.0.0.1:3000/'
    ```

    - ãƒ¬ã‚¹ãƒãƒ³ã‚¹
    ```json
    {
        "count": 1,
        "users": [
            {
                "email": "tanaka@example.com",
                "name": "ç”°ä¸­å¤ªéƒ",
                "user_id": "001"
            }
        ]
    }
    ```

## å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
ä»Šå›ã®å®Ÿè£…ã§ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

1. **DynamoDBã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼** (500 Internal Server Error)
   - DynamoDBã¸ã®æ¥ç¶šã«å¤±æ•—ã—ãŸå ´åˆ
   - scan/put_itemã®å®Ÿè¡Œã«å¤±æ•—ã—ãŸå ´åˆ

2. **ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼** (400 Bad Request)
   - ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ãŒç©ºã®å ´åˆ
   - JSONå½¢å¼ãŒä¸æ­£ãªå ´åˆ
   - å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒæ¬ ã‘ã¦ã„ã‚‹å ´åˆ

ã“ã‚Œã«ã‚ˆã‚Šã€é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã¨ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

### DynamoDBã®ãƒ‡ãƒ¼ã‚¿å‹å¤‰æ›
DynamoDBã‹ã‚‰å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã¯`AttributeValue`å‹ã§è¿”ã£ã¦ãã‚‹ãŸã‚ã€Rustã®æ§‹é€ ä½“ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```rust
item.get("user_id").and_then(|v| v.as_s().ok())
```

ã“ã®å‡¦ç†ã§ã¯:
- `get()`ã§AttributeValueã‚’å–å¾—
- `as_s()`ã§æ–‡å­—åˆ—å‹ã«å¤‰æ›ã‚’è©¦ã¿ã‚‹
- `ok()`ã§Resultå‹ã‚’Optionå‹ã«å¤‰æ›

è¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŒæ™‚ã«ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã€ã‚¿ãƒ—ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

### LocalStackã¨ã®é€šä¿¡
LocalStackã¯Dockerã‚³ãƒ³ãƒ†ãƒŠã§èµ·å‹•ã—ã¦ã„ã‚‹ãŸã‚ã€Lambdaé–¢æ•°ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹éš›ã¯`endpoint_url`ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```rust
let config = aws_config::defaults(BehaviorVersion::latest())
    .endpoint_url("http://localstack:4566")
    .load()
    .await;
```

`localstack`ã¨ã„ã†ãƒ›ã‚¹ãƒˆåã¯ã€`--docker-network`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§åŒã˜ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æ¥ç¶šã™ã‚‹ã“ã¨ã§åå‰è§£æ±ºãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

## å®Ÿéš›ã®é–‹ç™ºã§ã®å¿œç”¨ä¾‹

ã“ã®æ§‹æˆã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå ´åˆã«æœ‰åŠ¹ã§ã™ã€‚

### 1. ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã®æ§‹ç¯‰
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šä¸è¦ã§DynamoDBã‚’ä½¿ã£ãŸé–‹ç™ºãŒå¯èƒ½
- AWSåˆ©ç”¨æ–™é‡‘ã‚’æ°—ã«ã›ãšé–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆãŒã§ãã‚‹
- ãƒãƒ¼ãƒ å…¨ä½“ã§çµ±ä¸€ã•ã‚ŒãŸé–‹ç™ºç’°å¢ƒã‚’æ§‹ç¯‰ã§ãã‚‹
- ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ã¨å‰Šé™¤ãŒå®¹æ˜“

### 2. è¤‡æ•°ã®AWSã‚µãƒ¼ãƒ“ã‚¹ã¨ã®çµ±åˆãƒ†ã‚¹ãƒˆ
- LocalStackã¯DynamoDBä»¥å¤–ã«ã‚‚S3ã€SNSã€SQSãªã©æ§˜ã€…ãªAWSã‚µãƒ¼ãƒ“ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆ
- ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§è¤‡é›‘ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹æ§‹æˆã®ãƒ†ã‚¹ãƒˆãŒå¯èƒ½

## ãƒãƒã‚Šãƒã‚¤ãƒ³ãƒˆã¨å¯¾å‡¦æ³•

é–‹ç™ºä¸­ã«é­é‡ã—ã‚„ã™ã„å•é¡Œã¨è§£æ±ºç­–ã‚’ã¾ã¨ã‚ã¾ã™ã€‚

### 1. Dockerãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®è¨­å®š
**å•é¡Œ**: Lambdaé–¢æ•°ã‹ã‚‰LocalStackã«æ¥ç¶šã§ããªã„

**å¯¾å‡¦æ³•**:
```bash
# LocalStackã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯IDã‚’ç¢ºèª
docker network ls

# sam local start-apiã§åŒã˜ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’æŒ‡å®š
sam local start-api --docker-network <NETWORK_ID>
```

### 2. ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆURLã®æŒ‡å®š
**å•é¡Œ**: `localhost:4566`ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã—ã¦ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹

**å¯¾å‡¦æ³•**: Lambdaé–¢æ•°ã‚‚Dockerã‚³ãƒ³ãƒ†ãƒŠã§å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€`localhost`ã§ã¯ãªã`localstack`ã¨ã„ã†ãƒ›ã‚¹ãƒˆåã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### 3. ç’°å¢ƒå¤‰æ•°ã§ã®è¨­å®šåˆ‡ã‚Šæ›¿ãˆ
**å•é¡Œ**: æœ¬ç•ªç’°å¢ƒã¨ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆãŸã„

**å¯¾å‡¦æ³•**: ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã£ã¦å‹•çš„ã«åˆ‡ã‚Šæ›¿ãˆã‚‹å®Ÿè£…ä¾‹ã€‚
```rust
let endpoint_url = std::env::var("DYNAMODB_ENDPOINT")
    .ok();

let mut config_loader = aws_config::defaults(BehaviorVersion::latest());

if let Some(url) = endpoint_url {
    config_loader = config_loader.endpoint_url(url);
}

let config = config_loader.load().await;
```

## ã¾ã¨ã‚

ä»Šå›ã¯å‰å›ã®è¨˜äº‹ã«å¼•ãç¶šãã€Rust + SAM + LocalStackã‚’ä½¿ã£ã¦ã‚ˆã‚Šå®Ÿè·µçš„ãªAPIã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚

å®Ÿè£…ã—ãŸãƒã‚¤ãƒ³ãƒˆ:
- DynamoDBã¸ã®ãƒ‡ãƒ¼ã‚¿ç™»éŒ²(POST)
- DynamoDBã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿å–å¾—(GET)
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- JSONå½¢å¼ã§ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†

ã“ã®æ§‹æˆã‚’ä½¿ã†ã“ã¨ã§ã€AWSã¸ãƒ‡ãƒ—ãƒ­ã‚¤ã›ãšã«ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

ãœã²å‚è€ƒã«ã—ã¦ã€Rustã§ã®ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹é–‹ç™ºã‚’æ¥½ã—ã‚“ã§ãã ã•ã„ï¼